#### 20190417 ——  原始数据类型有有几种，null是不是对象，基本数据类型和引用数据类型再储存上的区别

1. 原始数据类型有：Number，String，Boolean，Null，Undefined，Symbol
2. null不是对象，它是原始数据类型
3. 基本数据类型存储在 栈中的值，引用数据类型存储的 是一个指针，而这个指针指向 内存堆中实际的值



#### 20190418 —— js中数据类型的转化规则

1. 转化为 Boolean类型
   - 转为true的有：  对象，长度不为0 的字符串，除了 0和NaN 的 数字类型；  其他都为  false
2. 转化为数字类型
   - Undefined，字符串，对象 转化为数字类型是  NaN
   - null 和 false 为 0； true为 1
   - 数字字符串转化为数字类型是   对应数字
3. 转化为字符串
   - 基本数据类型转字符串  加  ""
4. 转化对象类型： 
   - 会先调用 valueOf()方法，如果还没转成原始类型，再调用 toString()方法，



#### 20190419  ——   == 和 === 的区别？什么情况下用  == ？

1.  == 和 === 的区别
   - ==(相等运算符) ：会先判断数据类型相不相等，如果相等，再判断值相不相等；如果不相等，先转换数据类型，
   - ===(严格相等运算符) ：只有数据类型和值都相等，才会相等，不需要转换数据类型
2.  一般不建议使用 == ，推荐使用===，因为  == 存在类型转换，不确定因素多



#### 20190420 ——   为什么 0.1+0.2 != 0.3?

1. 首先计算机按照 IEEE754规则 把数字转成 二进制，转成二进制后，0.1和0.2都是 无线循环的小数，但由于受到IEEE754规则的限制，转成二进制的 数都会被位数限制，此时 0.1和0.2的精度都已缺失，就会造成 0.1+0.2!=0.3 的情况





#### 20190421 ——  深拷贝和浅拷贝的区别？如何实现？

1. 浅拷贝：如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址，修改其中任何一个值，另一个也会随之改变—— 浅拷贝
   - 实现方法：循环复制
   - Object.assign({},tian)
2. 深拷贝：将对象及值都复制过来，两个对象改变其中一个，另一个不会改变。
   - 递归法
   - JSON中的parse和stringify, 缺点：undefined，symbol和函数会被忽略



#### 20190422 ——  new的原理是什么？通过new的方式创建对象和通过字面量创建的有什么区别

1. new的原理：

   - 创建一个新对象
   - 将新对象链接到构造函数的原型上
   - 将构造函数的作用域复制给新对象，即this指向这个新对象
   - 如果没有返回其他对象，那么new表达式中的函数调用就会自动返回这个新对象

2. 通过new的方式创建对象和通过字面量创建的有什么区别

   - 字面量方式创建对象：没有两个绑定，this指向是的上下文的 对象，原型指向的是 Object

3. 创建对象的方式

   1. Object构造函数创建

      ```js
      var Person = new Object();
      Person.name = 'tiantian';
      // 缺点：产生大量重复代码
      ```

   2. 使用字面量的方式创建

      ```js
      var Person = {};
      var Person2 = {name: "tiantian"};
      // 缺点：产生大量重复代码
      ```

   3. 工厂模式创建对象

      ```js
      function createObj () {
        var o = new Object();
        o.name = "tian";
        o.age = 18;
        o.sayName = function () {
          console.log(this.name);
        }
        return o;
      }
      var p = createObj('tiantian',20);
      // 缺点：不能判断返回的对象时什么类型
      ```

   4. 构造函数创造对象

      ```js
      function Person (name,age) {
        this.name = "tian";
        this.age = 18;
        this.sayName = function () {
          console.log(this.name);
        }
      }
      var p = new Person('t',25);
      // 缺点：这样在每一个对象上都创建了相同的 方法和属性，占用了很多不比要的内存
      ```

   5. 用原型创建对象

      ```js
      function Person (name,age) {
        this.name = name;
        this.age = age;
      }
      Person.prototype.sayName = function () {
        console.log(this.name);
      }
      var p = new Person ('tian', 24);
      ```





#### 20190423 —— 如何正确判断 this？ 箭头函数的this是什么？

1. 判断this：调用的环境时判断其指向
   - 如果使用了new 绑定，this绑定 新创建的对象
   - 如果使用了 call、apply、bind绑定，this绑定的是指定的对象
   - 函数在某个上下文的对象中调用，this绑定的 是 那个上下文对象
   - 如果都不是，就默认绑定到 全局对象上(严格模式下，指向 undefined)
   - 箭头函数，this继承的是外层代码块上的this
2. 箭头函数的this:  箭头函数本身没有this，他的this 是继承的外层代码块的 this

#### 20190424 —— 什么是闭包？

1. 闭包就是把变量变成私有变量，然后暴露一个接口供外界通信，从而避免对全局的命名污染，主要用于封装私有变量，模仿块级作用域，实现js的模块化

#### 20190425 —— 如何理解原型？如何理解原型链？

1. 原型：当定义一个对象的时候，对象都会包含一些预定义的属性，每个函数对象都会有 prototype属性，这个属性就指向原型对象，使用原型的好处就是，所有的实例对象都会共享原型包含的属性和方法
2. 原型链主要解决的是继承的问题，每个对象都拥有一个原型对象，通过 proto 指向其原型对象，并从中继承属性和方法，同时这个原型也有自己的原型，这样一层层，最终指向 null(Object.protorype.__proto__)，通过原型链 链接一个对象，可以拥有定义在其他对象上的属性和方法

#### 20190426 —— 什么是变量提升？

1. 变量提升：变量提升，就是在声明之前就可以使用，但是值是 undefined

#### 20190427 —— typeof 和 instance of的区别？

1. typeof： 只能检测 基本数据类型，除了 null，输出的是 object
2. instanceof：只能检测引用数据类型，根据原型链判断的

#### 20190428 —— call、apply、bind函数内部实现是怎么样的？

1. call:
   - 将函数设为传入参数的属性
   - 指定this到函数并传入给定参数执行函数
   - 如果不传如参数或者参数为null，默认指向全局对象
   - 删除参数上的函数
2. apply: 和call类似，但是他们的参数是不一样的，apply的第二个参数是数组或者类数组
3. bind 和 call/apply 有一个很重要的区别，一个函数被 call/apply 的时候，会直接调用，但是 bind 会创建一个新函数。当这个新函数被调用时，bind() 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。

#### 20190429 —— 请说一下你对 js 执行上下文栈和作用?

1. js执行上下文栈：就是 js解析和执行所在的环境，js执行上下文栈 可以认为是一个存储函数调用的栈结构，遵循先进后出的原则。
   - js是单线程的，代码排队执行
   - 一开始浏览器执行全局代码时，首先创建全局的执行上下文，压入执行栈的顶部
   - 每当进入一个函数执行，就会创建函数的执行上下文，并压入执行栈顶部
   - 当前函数执行完成后，当前函数执行上下文出栈，并等待垃圾回收
   - 浏览器的js执行引擎总是访问栈顶的执行上下文
   - 全局上下文只有唯一一个，在关闭浏览器关闭时出栈
2. 作用：让js代码有序执行

#### 20190430 —— 为什么会出现 setTimeout倒计时误差？如何减少误差？

1. setTimeout()只是 将事件插入了 "任务队列"，必须等到当前代码执行完，主线程才会执行它指定的函数，当前代码的执行时间并不确定，所以没办法保证回调函数一定在 setTimeout()指定的时间执行，setTimeout()指定的第二个参数表示的是最少的时间，并非是确切的时间。
2. 如何减少误差：HTML5规定，setTimeout()的第二个参数最小值不得小于4ms，如果对于DOM的变动，间隔是 16ms，这是使用 requestAnimationFrame()的效果好浩宇 setTimeout()。



